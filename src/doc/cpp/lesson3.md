---
title: 基础数据类型
order: 3
---

## 数据类型对应的范围

- bit：位(1个二进制位)，计算机储存的最小单位
- Byte：字节（8个连续的二进制位），计算机储存的基本单位
- $1$ B(Byte) = $8$ bit
- $1$ KB(KiB) = $1024$ B（$2^{10}$ B）
- $1$ MB(MiB) = $1024$ KB
- $1$ GB(GiB) = $1024$ MB
- $1$ TB(TiB) = $1024$ GB
- $1$ PB(PiB) = $1024$ TB

| 数据类型名           | 内容(一般情况)   | 占用内存大小 | 能储存的范围                                                              | `scanf`/`printf` 标识符(g++) |
| -------------------- | ---------------- | ------------ | ------------------------------------------------------------------------- | ---------------------------- |
| `int`/`signed`       | 32 位整数        | 4 Bytes      | $-2^{31}\sim 2^{31}-1$ <br> 约 $-2\times 10^9\sim 2\times 10^9$           | `%d`/`%d`                    |
| `long long`          | 64 位整数        | 8 Bytes      | $-2^{63}\sim 2^{63}-1$ <br> 约 $-9\times 10^{18}\sim 9\times 10^{18}$.    | `%lld`/`%lld`                |
| `char`               | 字符             | 1 Byte       | 至少能储存 $0\sim 127$ <br> 常见范围为 $-128\sim 127$                     | `%c`/`%c`                    |
| `float`              | 单精度浮点数     | 4 Bytes      | $-3.4\times 10^{38}\sim 3.4\times 10^{38}$ <br> 有效数字 $6\sim 7$ 位     | `%f`/`%f`                    |
| `double`             | 双精度浮点数     | 8 Bytes      | $-1.7\times 10^{308}\sim 1.7\times 10^{308}$ <br> 有效数字 $15\sim 16$ 位 | `%lf`/`%f`                   |
| `unsigned int`       | 无符号 32 位整数 | 4 Bytes      | $0 \sim 2^{32}-1$ <br> 约 $0 \sim 4\times 10^9$                           | `%u`/`%u`                    |
| `unsigned long long` | 无符号 64 位整数 | 8 Bytes      | $0 \sim 2^{64}-1$ <br> 约 $0 \sim 1.8\times 10^{19}$                      | `%llu`/`%llu`                |

## 整数编码

### 基础二进制

- 二进制即要求满二进一，因此每一位为 $0$ 或 $1$
- 二进制从最低位到最高位，数位的权值分别为：$2^0,2^1,2^2,2^3,\dots$
- 即 $1,2,4,8,16,32,64,128,\dots$
- $(101101)_2$ 转换成十进制结果如下

```
原始数位： 1  0 1 1 0 1
对应权值：32 16 8 4 2 1
转十进制：32 + 8 + 4 + 1 = 45
```

### 原码、反码、补码

- 原码
  - 最高位为符号位，正数为 $0$，负数为 $1$。
  - 剩下位置为原数绝对值的二进制。
- 反码
  - 正数反码与原码一致。
  - 负数反码除最高位之外，在原码基础上取反。
- 补码
  - 正数补码与原码一致
  - 负数补码在反码基础上加 $1$。

## 讨厌的浮点数

### 保留 $x$ 位小数

#### 方法 1

- 头文件：`#include <cstdio>`（`<bits/stdc++.h>` 包含了这个头文件）
- 语句： `printf("%.xf", a);`

#### 方法 2（推荐）

- 头文件：`#include<iostream>`、`#include<iomanip>`（`<bits/stdc++.h>` 包含了这两个头文件）
- 语句：`cout << fixed << setprecision(x) << a;`

### 关于四舍五入


如果题目说保留 $x$ 位小数，那么就按照上面方式输出就可以了。  

但是需要注意的是，这种方式并不是我们直观中的四舍五入。

对于 $4$ 舍和 $6$ 入的部分是没有问题的，对于舍入位是 $5$，且后面还有大于 $0$ 的数位时也是没有问题的。但如果舍入位是 $5$ 且后没有其他数了，那么有可能会有两个小问题。  

**如果是 `double` 类型可以精确储存的数**，那么会舍入到最接近的偶数数位，比如在保留 $0$ 位小数的情况下：  

- $0.5$ -> $0$
- $1.5$ -> $2$
- $2.5$ -> $2$
- $3.5$ -> $4$

保留 $2$ 位小数的情况下：

- $1.125$ -> $1.12$
- $1.375$ -> $1.38$

**如果是 `double` 类型无法无法精确储存的数**，实际上储存的数可能会有一点点偏差，也会造成和我们所想不同。  
比如如果输入 $1.115$，那么保留 $2$ 位小数输出的会是 $1.11$，因为保留 $20$ 位小数输出后，我们会发现实际储存的数大概是 $1.11499999999999999112$，执行的自然是 $4$ 舍操作。

现在的出题人一般都不会说四舍五入，而是用精度控制，比如相对或绝对误差在 $10^{-6}$（即 $0.000001$）以内就算对，此时你保留 $7$ 位小数就肯定够了。

## 字符与整数的对应转换

```cpp
char c;
int a;
```

### 数字字符与对应整数

- `'0' ~ '9'` 对应的 ASCII 为 `48 ~ 57`
- 数字字符转换为对应整数：`(int)(c - '0')`
- 数字转换为对应字符：`(char)(a + '0')`

### 大小写字母映射到 $0\sim 25$

- `'a' ~ 'z'` 对应的 ASCII 为 `97 ~ 122`
- `'A' ~ 'Z'` 对应的 ASCII 为 `65 ~ 90`
- 大写字母映射到 $0\sim 25$：`(int)(c - 'A')`
- 小写字母映射到 $0\sim 25$：`(int)(c - 'a')`

### 大小写字母之间转换

- 大写转小写：`(char)(c - 'A' + 'a')`
- 小写转大写：`(char)(c - 'a' + 'A')`

## 其他常见基础操作

### 数位分解

- `% 10`：取出个位
- `/ 10`：去掉个位
- 个位：`a % 10`
- 十位：`a / 10 % 10`
- 百位：`a / 100 % 10`
- 千位：`a / 1000 % 10`

### 闰年判断

- 普通闰年：`y % 4 == 0 && y % 100 != 0`
- 世纪闰年：`y % 400 == 0`
- 闰年判断：`(y % 4 == 0 && y % 100 != 0) || y % 400 == 0`
  - 因为 `&&` 优先级高于 `||`，所以不写那个小括号也可以。

### 三角形判断

任意两边之和大于第三边。

`a + b > c && a + c > b && b + c > a`

### 上下取整

`int p, q, x;`，这里我们只讨论 $p,q\gt 0$ 的情况。

- 下取整（$x = \lfloor \frac{p}{q}\rfloor$）
  - `x = p / q`
- 上取整（$\lceil \frac{p}{q}\rceil$）
  - ```cpp
    if (p % q == 0) 
        x = p / q; 
    else 
        x = p / q + 1;
  - `x = (p + (q - 1)) / q;`
  - `x = p / q + (p % q != 0);`

### 类型转换

- 用一个目标类型的数参与运算（必须是更优先的类型）：
  - `1.0 * a`
  - `1LL * a`（默认情况下 `1` 为 `int` 类型，在后面加上 `ll` 或 `LL` 可以得到一个 `long long` 类型的 `1`）
- 存入一个目标类型的变量：
  - `char c = 'a' - 32;`
- 用 `(type)` 前缀，这个前缀会把紧跟着的数变为 `type` 类型。
  - `(double)p / q`
  - `(char)('a' - 32)`